{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"What is LegoCity","text":"<p>LegoCity is a Smart City Builder that provides a reusable foundation for building city dashboards and applications on top of FIWARE / NGSI-LD and modern web technologies.</p> <p>It combines:</p> <ul> <li>a context layer based on NGSI-LD context brokers and FIWARE Smart Data Models  </li> <li>a UI layer built with Next.js, Mapbox GL JS, and PayloadCMS</li> </ul> <p>Instead of hard-coding a single dashboard, LegoCity is designed so that different cities or teams can reuse the same core and plug in their own data, map views, layers, and layouts.</p>"},{"location":"#core-ideas","title":"Core ideas","text":"<p>LegoCity is built around the following principles.</p>"},{"location":"#context-centric-design","title":"Context-centric design","text":"<p>City information (sensors, services, zones, infrastructure) is modeled as NGSI-LD entities in one or more context brokers. The broker is treated as the primary source of truth.</p>"},{"location":"#configuration-driven-ui","title":"Configuration-driven UI","text":"<p>Dashboards are constructed from map views, layers, and blocks defined in PayloadCMS. Most changes should be made by configuration rather than modifying frontend code.</p>"},{"location":"#reusability-across-deployments","title":"Reusability across deployments","text":"<p>The same codebase can be reused in multiple cities:</p> <ul> <li>context brokers and data sources can change  </li> <li>map styles and views can be reconfigured  </li> <li>pages and blocks can be added or removed  </li> </ul> <p>without redesigning the entire system.</p>"},{"location":"#ai-as-an-optional-assistant","title":"AI as an optional assistant","text":"<p>LegoCity works fully without AI. AI integration in PayloadCMS is treated as a secondary, optional feature for authoring and documentation support.</p>"},{"location":"#architecture-overview","title":"Architecture overview","text":"<p>LegoCity is structured into three main layers.</p>"},{"location":"#1-context-and-data-layer-fiware-ngsi-ld","title":"1. Context and data layer (FIWARE / NGSI-LD)","text":"<ul> <li>One or more NGSI-LD context brokers (for example, Orion-LD)  </li> <li>City data represented as entities, such as:</li> <li>weather and air quality observations  </li> <li>flood zones and risk areas  </li> <li>parking and mobility  </li> <li>public services and facilities  </li> <li>Where applicable, entities follow FIWARE Smart Data Models to keep naming and structure consistent  </li> <li>Update services that:</li> <li>retrieve data from external sources (open data APIs, sensor gateways, GTFS, etc.)  </li> <li>transform it into NGSI-LD entities  </li> <li>write it to the broker  </li> </ul> <p>This layer defines the canonical view of the city context.</p>"},{"location":"#2-application-and-proxy-layer","title":"2. Application and proxy layer","text":"<ul> <li>Lightweight services that:</li> <li>query the context broker  </li> <li>apply filtering, aggregation, or domain logic  </li> <li>expose stable, documented HTTP endpoints to the UI  </li> <li>A proxy component that:</li> <li>hides API keys and internal endpoints  </li> <li>enforces authentication, authorization, and rate limiting where required  </li> <li>normalizes responses into formats the dashboard expects  </li> </ul>"},{"location":"#3-ui-and-configuration-layer-dashboard-payloadcms","title":"3. UI and configuration layer (Dashboard + PayloadCMS)","text":"<ul> <li>A Next.js + Mapbox dashboard that:</li> <li>renders maps in 2D and 3D  </li> <li>displays layers for different entity types  </li> <li>provides tables, indicators, detail panels, and filters  </li> <li>A PayloadCMS admin interface that allows:</li> <li>defining map views (base style, initial center, zoom level)  </li> <li>registering layers (which entities or queries to display and how to style them)  </li> <li>assembling pages from reusable blocks (map, table, KPI, detail, filter, etc.)  </li> <li>optionally configuring AI helpers  </li> </ul> <p>Configuration changes are made in PayloadCMS and reflected by the dashboard without code changes.</p>"},{"location":"#use-cases","title":"Use cases","text":"<p>LegoCity is intended to support several categories of smart-city applications.</p>"},{"location":"#city-dashboards","title":"City dashboards","text":"<p>Internal dashboards for city departments (planning, environment, transport, public works) that need:</p> <ul> <li>an integrated view of key indicators on a city map  </li> <li>monitoring of sensors and assets over time  </li> <li>comparison of different districts or scenarios  </li> </ul>"},{"location":"#public-information-portals","title":"Public information portals","text":"<p>Public-facing sites in which citizens can:</p> <ul> <li>locate nearby public services and infrastructure  </li> <li>view alerts and warnings (flood, pollution, events)  </li> <li>explore open city data through a map-based interface  </li> </ul>"},{"location":"#education-and-research","title":"Education and research","text":"<p>A reference stack for:</p> <ul> <li>teaching FIWARE / NGSI-LD using a realistic architecture  </li> <li>prototyping smart city use cases in courses, projects, and hackathons  </li> <li>publishing reproducible examples that other teams can adapt  </li> </ul>"},{"location":"#rapid-prototyping-for-city-projects","title":"Rapid prototyping for city projects","text":"<p>A starting point for new initiatives where teams need to:</p> <ul> <li>integrate a small number of data sources quickly  </li> <li>define entities, map views, and layers  </li> <li>present a working dashboard before committing to a bespoke solution  </li> </ul>"},{"location":"#key-concepts","title":"Key concepts","text":"<p>For the rest of the documentation, the following terms are used consistently.</p>"},{"location":"#context-broker","title":"Context broker","text":"<p>A service that implements the NGSI-LD API, stores entities, and exposes operations to:</p> <ul> <li>create and update entities  </li> <li>query current context  </li> <li>subscribe to changes  </li> </ul> <p>In LegoCity, the context broker is the central component of the data layer.</p>"},{"location":"#entity","title":"Entity","text":"<p>A representation of a real-world object or observation in the city, for example:</p> <ul> <li>a weather observation at a given point  </li> <li>a flood zone defined by a polygon  </li> <li>a parking facility  </li> <li>a public service location  </li> </ul> <p>Entities have a <code>type</code>, properties (including geospatial properties), and may have relationships to other entities.</p>"},{"location":"#smart-data-models","title":"Smart Data Models","text":"<p>Standard schemas for common smart-city entities provided by the FIWARE Smart Data Models initiative. Using these models:</p> <ul> <li>improves consistency between deployments  </li> <li>simplifies documentation and interoperability  </li> </ul>"},{"location":"#map-view","title":"Map view","text":"<p>A named configuration of a map, including:</p> <ul> <li>base style  </li> <li>initial center and zoom level  </li> <li>the set of layers that can be shown in that view  </li> </ul>"},{"location":"#layer","title":"Layer","text":"<p>A definition that connects:</p> <ul> <li>a data source or query (which entities are displayed)  </li> <li>a visual style (how those entities are rendered on the map)  </li> </ul> <p>Layers are defined in PayloadCMS and translated into Mapbox sources and layers in the UI.</p>"},{"location":"#block","title":"Block","text":"<p>A reusable UI component in the dashboard, such as:</p> <ul> <li>map block  </li> <li>table block  </li> <li>KPI/indicator block  </li> <li>detail block  </li> <li>filter or control block  </li> </ul> <p>A page is composed of a sequence of blocks whose configuration is stored in PayloadCMS.</p>"},{"location":"#ai-helper-optional","title":"AI helper (optional)","text":"<p>An optional feature that uses AI within PayloadCMS to:</p> <ul> <li>assist with writing descriptions  </li> <li>generate seed data or examples  </li> <li>draft documentation or helper text  </li> </ul> <p>AI helpers are not required for LegoCity to function and can be enabled or disabled per deployment.</p>"},{"location":"#when-legocity-is-a-suitable-choice","title":"When LegoCity is a suitable choice","text":"<p>LegoCity is suitable when:</p> <ul> <li>the project involves city or regional data with a clear notion of entities and context  </li> <li>FIWARE / NGSI-LD or compatible standards are part of the technical direction  </li> <li>there is a requirement for both a map-based dashboard and a configurable admin UI for non-developers  </li> <li>new views, layers, and pages are expected to be added over time  </li> </ul>"},{"location":"#when-legocity-may-be-unnecessary","title":"When LegoCity may be unnecessary","text":"<p>LegoCity may be unnecessarily complex when:</p> <ul> <li>only a single, static dashboard is required  </li> <li>the domain does not involve city context or geospatial entities  </li> <li>a simple map widget embedded in an existing application is sufficient  </li> <li>FIWARE / NGSI-LD will not be used at all  </li> </ul>"},{"location":"#next-steps","title":"Next steps","text":"<p>For readers new to the project, a reasonable path through the documentation is:</p> <ol> <li>Read this introduction to understand the overall purpose and architecture  </li> <li>Proceed to the Usage section to see how context brokers, entities, map views, and layers are connected  </li> <li>Continue to the Deployment section to learn how to run LegoCity on specific infrastructure  </li> <li>Consult the Development &amp; Contribute section when extending LegoCity with new blocks, plugins, or data seeds  </li> </ol>"},{"location":"Open_Source_Checklist/","title":"The Open Source Checklist","text":""},{"location":"Open_Source_Checklist/#about","title":"About","text":"<p>It's easy to overlook important tasks when releasing and maintaining an open source project. This checklist helps ensure your project follows best practices for health, development, and security.</p> <p>Use this checklist as a discussion starter for your team and a foundation for continuous improvement.</p>"},{"location":"Open_Source_Checklist/#archiving-and-deprecating-a-project","title":"Archiving and Deprecating a Project","text":"<ul> <li>Should use the platform's \"Archival\" function. This way, it becomes read-only, including the issues board, and is flagged as inactive.</li> <li>Should state in the README that the project is no longer maintained.</li> <li>Should be archived if there are no maintainers.</li> </ul>"},{"location":"Open_Source_Checklist/#documentation","title":"Documentation","text":"<ul> <li> <p>Must ensure the project includes standard Community Health Files (CHANGELOG, CONTRIBUTING, CODE_OF_CONDUCT, etc.).   See the README.md Template Files section for a complete list.</p> </li> <li> <p>Should include usage documentation and architecture descriptions relevant to the project.</p> </li> </ul>"},{"location":"Open_Source_Checklist/#legal-and-licensing","title":"Legal and Licensing","text":"<ul> <li>Must ensure the project's license doesn't conflict with third-party licenses.</li> <li>License declarations must follow the REUSE licensing specification, ensuring all materials have clear copyright information.</li> </ul>"},{"location":"Open_Source_Checklist/#naming-and-trademarks-check","title":"Naming and Trademarks Check","text":"<ul> <li>Should ensure that the project name does not conflict with an existing project or infringe on trademarks.</li> <li>Conduct a general search engine check for the proposed project name.</li> <li>Perform a Trademark Search.</li> </ul> <p>Note: It might be perfectly acceptable to use a name reminiscent of an existing trademark - if the existing trademark is used for other services/areas and is not recognized as a well-known trademark.</p>"},{"location":"Open_Source_Checklist/#people-maintenance","title":"People &amp; Maintenance","text":"<ul> <li>Must ensure maintainers have education or experience with open source. For example, reading guides at https://opensource.guide.</li> <li>Must ensure maintainers have a plan for handling merge/pull requests (code reviews, etc.).</li> <li>Must ensure maintainers have a plan for community engagement (responding to issues, reviewing pull requests).</li> <li>Must ensure someone is responsible for security issues.</li> <li> <p>Must include a <code>Maintainer</code> section in every project README (team, individual, or role).</p> </li> <li> <p>Should establish a release plan with clear announcement and promotion strategies.</p> </li> <li>Should use a CODEOWNERS file for granular maintenance descriptions (complementing the README's general Maintainer section).</li> </ul>"},{"location":"Open_Source_Checklist/#project-quality","title":"Project Quality","text":"<ul> <li>Must verify that the project has undergone a code review.</li> <li>Should discuss and establish the project's testing goals and ambitions.</li> <li>Should make it easy to use the project - documentation, examples, pre-built releases, etc.</li> </ul>"},{"location":"Open_Source_Checklist/#release-and-versioning","title":"Release and Versioning","text":"<ul> <li>Should use Semantic Versioning 2.0.0 and release tags.</li> </ul>"},{"location":"Open_Source_Checklist/#security","title":"Security","text":"<p>This part of the checklist is based on the Open Source Security Foundation (OpenSSF) guide for more secure open source development, version: 2023-06-14, (and companion post).</p>"},{"location":"Open_Source_Checklist/#general","title":"General","text":"<ul> <li>Must use two-factor authentication (2FA) or multifactor authentication (MFA) to make it harder for account takeovers.</li> <li>Must limit merge and push rights to specific branches.</li> <li>Must have enabled branch protection.</li> <li> <p>Must have a practice of signed commits.</p> </li> <li> <p>Should have a basic knowledge of committers and maintainers, and must do a periodic review of those.</p> </li> <li>Should have automated testing and test coverage practices, including tests for negative cases, to detect bugs and secure the project.</li> </ul>"},{"location":"Open_Source_Checklist/#contribution","title":"Contribution","text":"<ul> <li>Should have a practice of code reviews.</li> <li>Should have good readability and scope requirements to ensure new PRs are not obfuscated, and use of opaque binaries is minimized.</li> </ul>"},{"location":"Open_Source_Checklist/#dependencies-and-vulnerabilities-detection","title":"Dependencies and Vulnerabilities Detection","text":"<ul> <li>Must use SCA-tools in the CI pipeline to detect vulnerabilities and license incompatibilities.</li> <li>Must use linter tools in the CI pipeline to detect vulnerabilities and bad development practices.</li> <li>Must use secret scanning tools to detect secrets (passwords, logs, tokens).</li> <li>Must use automated tooling to monitor dependency updates for critical vulnerabilities.</li> <li> <p>Must have maintenance to quickly handle updating vulnerabilities.</p> </li> <li> <p>Should use SAST-tools in the CI pipeline to detect potential vulnerabilities and bad software practices.</p> </li> <li>Should evaluate the health of every new direct project dependency that is added to the project.</li> <li>Should prefer using package managers (at the system, language, and container level) for automatic and consistent dependency updates.</li> </ul>"},{"location":"Open_Source_Checklist/#publishing","title":"Publishing","text":"<ul> <li>Must produce an SBOM (Software Bill of Materials) for the project so that end-users and systems can verify vulnerabilities and license incompatibilities.</li> <li> <p>Must limit software publishing rights of artifacts.</p> </li> <li> <p>Should sign any project releases.</p> </li> <li>Should make it easy for end-users to upgrade to new releases. Use semantic versioning, support stable APIs, and flag deprecation early.</li> </ul>"},{"location":"Open_Source_Checklist/#policy","title":"Policy","text":"<ul> <li>Must have a security policy in place - it should contain information about where to report non-disclosure vulnerabilities and the process regarding the report.</li> </ul> <p>Secure software practices and tooling from OpenSSF and OWASP:</p>"},{"location":"Open_Source_Checklist/#tooling","title":"Tooling","text":"<ul> <li>OpenSSF guide to security tools.</li> <li>OWASP Application Security Tools</li> <li>OpenSSF Scorecards for repository security</li> </ul>"},{"location":"Open_Source_Checklist/#guides","title":"Guides","text":"<ul> <li>OpenSSF's Concise Guide for Evaluating Open Source Software</li> <li>CNCF Security TAG Software Supply Chain Best Practices guide.</li> <li>OWASP Cheatsheets.</li> <li>OWASP Software Developer Guide.</li> <li>Signing artifacts in the supply chain - OpenSSF sigstore project.</li> <li>OWASP Application Security Verification Standard - ASVS.</li> <li>Supply-chain Levels for Software Artifacts - (SLSA).</li> </ul>"},{"location":"Open_Source_Checklist/#workflows","title":"Workflows","text":"<ul> <li>May discuss your GitHub workflow - a brief summary and suggestion can be found in CONTRIBUTING - Pull Request Lifecycle</li> </ul>"},{"location":"Open_Source_Checklist/#specifications-and-standards-to-follow","title":"Specifications and Standards to Follow","text":"<p>The following will help your Open Source Project to be collaborative, reusable, accessible, and up-to-date.</p> <ul> <li>REUSE License specification</li> <li> <p>Ensures clear and standardized license compliance across the project.</p> </li> <li> <p>Conventional Commits format</p> </li> <li> <p>Provides a clear and structured project history through standardized commit messages.</p> </li> <li> <p>Keep-A-Changelog format</p> </li> <li> <p>Maintains a clear and user-friendly release history.</p> </li> <li> <p>Semantic Versioning 2.0.0</p> </li> <li> <p>Provides consistent version numbering for releases.</p> </li> <li> <p>Contributor Covenant guidelines</p> </li> <li> <p>Establishes a social contract for respectful and inclusive collaboration.</p> </li> <li> <p>OpenSSF Scorecard</p> </li> <li> <p>Helps assess and improve the security health of our project.</p> </li> <li> <p>PublicCode.yml</p> </li> <li> <p>Facilitates easy metadata indexing for better discoverability of our project.</p> </li> <li> <p>Standard for Public Code</p> </li> <li>Ensures the project meets criteria for public code quality and sustainability.</li> </ul>"},{"location":"ai/openrouter/","title":"D\u00f9ng OpenRouter l\u00e0m custom provider","text":""},{"location":"ai/openrouter/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn s\u1eed d\u1ee5ng OpenRouter \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"ai/openrouter/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>OpenRouter introduction</li> <li>Setup custom models</li> <li>Gemini 2.0 Flash integration</li> <li>GPT-4o Mini configuration</li> <li>Claude 3.5 Sonnet setup</li> <li>Cost optimization</li> <li>Fallback strategies</li> </ul>"},{"location":"ai/overview/","title":"Gi\u1edbi thi\u1ec7u plugin AI","text":""},{"location":"ai/overview/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn t\u00edch h\u1ee3p AI v\u00e0o LegoCity \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"ai/overview/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>T\u1ed5ng quan payload-ai plugin</li> <li>Use cases cho Smart City</li> <li>AI-powered content generation</li> <li>Intelligent configuration suggestions</li> <li>Automated documentation</li> <li>Data analysis v\u00e0 insights</li> </ul>"},{"location":"ai/providers/","title":"C\u1ea5u h\u00ecnh OpenAI / Anthropic / ElevenLabs","text":""},{"location":"ai/providers/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn c\u1ea5u h\u00ecnh AI providers \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"ai/providers/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>OpenAI GPT-4 configuration</li> <li>Anthropic Claude setup</li> <li>ElevenLabs voice integration</li> <li>API keys management</li> <li>Rate limits v\u00e0 pricing</li> <li>Best practices</li> </ul>"},{"location":"ai/use-cases/","title":"Use case g\u1ee3i \u00fd cho LegoCity","text":""},{"location":"ai/use-cases/#coming-soon","title":"Coming soon","text":"<p>C\u00e1c use case AI cho Smart City \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"ai/use-cases/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Content generation cho posts/pages</li> <li>Layer description automation</li> <li>Configuration suggestions</li> <li>Documentation assistant</li> <li>Seed data generation</li> <li>Intelligent search</li> <li>Chatbot cho citizens</li> <li>Predictive analytics</li> </ul>"},{"location":"deployment/aws/","title":"Deploy tr\u00ean AWS","text":""},{"location":"deployment/aws/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn chi ti\u1ebft deploy LegoCity l\u00ean AWS \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"deployment/aws/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Setup EC2 instances</li> <li>Configure RDS for MongoDB</li> <li>Setup ECS/EKS for containers</li> <li>CloudFront CDN configuration</li> <li>Route 53 DNS setup</li> <li>Security groups v\u00e0 IAM roles</li> <li>Auto-scaling configuration</li> <li>Backup v\u00e0 disaster recovery</li> </ul>"},{"location":"deployment/cloudflare/","title":"Deploy v\u1edbi Cloudflare","text":""},{"location":"deployment/cloudflare/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn chi ti\u1ebft deploy LegoCity v\u1edbi Cloudflare \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"deployment/cloudflare/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Deploy dashboard l\u00ean Cloudflare Pages</li> <li>Setup Cloudflare Workers cho API</li> <li>Configure Cloudflare Tunnels</li> <li>R2 storage configuration</li> <li>CDN v\u00e0 caching strategies</li> <li>Security v\u00e0 DDoS protection</li> </ul>"},{"location":"deployment/coolify/","title":"Deploy v\u1edbi Coolify","text":""},{"location":"deployment/coolify/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn chi ti\u1ebft deploy LegoCity v\u1edbi Coolify \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"deployment/coolify/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Setup Coolify instance</li> <li>Connect Git repository</li> <li>One-click deployment</li> <li>Environment variables configuration</li> <li>Automatic SSL setup</li> <li>Database management</li> <li>Monitoring dashboard</li> <li>Update v\u00e0 rollback</li> </ul>"},{"location":"deployment/overview/","title":"T\u1ed5ng quan Deployment","text":""},{"location":"deployment/overview/#kien-truc-trien-khai","title":"Ki\u1ebfn tr\u00fac tri\u1ec3n khai","text":"<p>LegoCity c\u00f3 th\u1ec3 tri\u1ec3n khai theo nhi\u1ec1u c\u00e1ch:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Load Balancer / CDN         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                     \u2502\n\u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n\u2502Dashboard \u2502      \u2502  Orion-LD  \u2502\n\u2502(Next.js) \u2502      \u2502  (Broker)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502                     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\n         \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 MongoDB  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"deployment/overview/#cac-nen-tang-ho-tro","title":"C\u00e1c n\u1ec1n t\u1ea3ng h\u1ed7 tr\u1ee3","text":""},{"location":"deployment/overview/#1-aws-production-ready","title":"1. AWS (Production Ready)","text":"<ul> <li>EC2 - M\u00e1y \u1ea3o</li> <li>ECS/EKS - Container orchestration</li> <li>RDS - MongoDB managed</li> <li>CloudFront - CDN</li> <li>Route 53 - DNS</li> </ul> <p>Chi ti\u1ebft \u2192</p>"},{"location":"deployment/overview/#2-cloudflare-edge-computing","title":"2. Cloudflare (Edge Computing)","text":"<ul> <li>Pages - Static hosting cho dashboard</li> <li>Workers - Serverless functions</li> <li>R2 - Object storage</li> <li>Tunnels - Expose local services</li> </ul> <p>Chi ti\u1ebft \u2192</p>"},{"location":"deployment/overview/#3-vps-may-ao-self-hosted","title":"3. VPS / M\u00e1y \u1ea3o (Self-hosted)","text":"<ul> <li>Ubuntu/Debian server</li> <li>Docker + Docker Compose</li> <li>Nginx reverse proxy</li> <li>Let's Encrypt SSL</li> </ul> <p>Chi ti\u1ebft \u2192</p>"},{"location":"deployment/overview/#4-coolify-paas","title":"4. Coolify (PaaS)","text":"<ul> <li>One-click deployment</li> <li>T\u1ef1 \u0111\u1ed9ng SSL</li> <li>Built-in monitoring</li> <li>Git-based deployment</li> </ul> <p>Chi ti\u1ebft \u2192</p>"},{"location":"deployment/overview/#yeu-cau-he-thong","title":"Y\u00eau c\u1ea7u h\u1ec7 th\u1ed1ng","text":""},{"location":"deployment/overview/#toi-thieu","title":"T\u1ed1i thi\u1ec3u","text":"<ul> <li>CPU: 2 cores</li> <li>RAM: 4GB</li> <li>Disk: 20GB SSD</li> <li>Network: 100Mbps</li> </ul>"},{"location":"deployment/overview/#khuyen-nghi-production","title":"Khuy\u1ebfn ngh\u1ecb (Production)","text":"<ul> <li>CPU: 4+ cores</li> <li>RAM: 8GB+</li> <li>Disk: 50GB+ SSD</li> <li>Network: 1Gbps</li> <li>Backup: Daily automated</li> </ul>"},{"location":"deployment/overview/#environment-variables","title":"Environment Variables","text":"<p>C\u00e1c bi\u1ebfn m\u00f4i tr\u01b0\u1eddng c\u1ea7n thi\u1ebft:</p> <pre><code># Database\nDATABASE_URI=mongodb://localhost:27017/legocity\n\n# Payload CMS\nPAYLOAD_SECRET=your-secret-key-32-chars-min\nNEXT_PUBLIC_SERVER_URL=https://yourdomain.com\n\n# Orion-LD\nORION_URL=http://localhost:1026\n\n# Optional: AI Integration\nOPENAI_API_KEY=sk-...\nANTHROPIC_API_KEY=sk-ant-...\n\n# Optional: Monitoring\nSENTRY_DSN=https://...\n</code></pre>"},{"location":"deployment/overview/#checklist-truoc-khi-deploy","title":"Checklist tr\u01b0\u1edbc khi deploy","text":"<ul> <li>[ ] \u0110\u00e3 c\u1ea5u h\u00ecnh domain v\u00e0 DNS</li> <li>[ ] \u0110\u00e3 chu\u1ea9n b\u1ecb SSL certificate</li> <li>[ ] \u0110\u00e3 backup d\u1eef li\u1ec7u (n\u1ebfu migrate)</li> <li>[ ] \u0110\u00e3 test tr\u00ean staging environment</li> <li>[ ] \u0110\u00e3 thi\u1ebft l\u1eadp monitoring</li> <li>[ ] \u0110\u00e3 c\u1ea5u h\u00ecnh backup t\u1ef1 \u0111\u1ed9ng</li> <li>[ ] \u0110\u00e3 document c\u00e1c API keys</li> <li>[ ] \u0110\u00e3 thi\u1ebft l\u1eadp rollback plan</li> </ul>"},{"location":"deployment/overview/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>S\u1eed d\u1ee5ng HTTPS - B\u1eaft bu\u1ed9c cho production</li> <li>Environment Variables - Kh\u00f4ng commit v\u00e0o Git</li> <li>Firewall Rules - Ch\u1ec9 m\u1edf ports c\u1ea7n thi\u1ebft</li> <li>Regular Updates - Update dependencies \u0111\u1ecbnh k\u1ef3</li> <li>Rate Limiting - Ch\u1ed1ng DDoS v\u00e0 abuse</li> <li>Backup Strategy - Backup daily + retention policy</li> <li>Access Control - Ph\u00e2n quy\u1ec1n r\u00f5 r\u00e0ng</li> <li>Monitoring - Alert khi c\u00f3 v\u1ea5n \u0111\u1ec1</li> </ol>"},{"location":"deployment/overview/#deployment-flow","title":"Deployment Flow","text":"<pre><code>graph LR\n    A[Code Push] --&gt; B[CI/CD Pipeline]\n    B --&gt; C[Build &amp; Test]\n    C --&gt; D{Tests Pass?}\n    D --&gt;|Yes| E[Build Docker Image]\n    D --&gt;|No| F[Notify Developers]\n    E --&gt; G[Push to Registry]\n    G --&gt; H[Deploy to Staging]\n    H --&gt; I{Manual Approval}\n    I --&gt;|Approved| J[Deploy to Production]\n    I --&gt;|Rejected| F\n    J --&gt; K[Health Check]\n    K --&gt; L{Healthy?}\n    L --&gt;|Yes| M[Success]\n    L --&gt;|No| N[Rollback]\n</code></pre>"},{"location":"deployment/overview/#tiep-theo","title":"Ti\u1ebfp theo","text":"<p>Ch\u1ecdn n\u1ec1n t\u1ea3ng ph\u00f9 h\u1ee3p:</p> <ul> <li>Deploy tr\u00ean AWS</li> <li>Deploy v\u1edbi Cloudflare</li> <li>Deploy tr\u00ean VPS</li> <li>Deploy v\u1edbi Coolify</li> </ul>"},{"location":"deployment/vm/","title":"Deploy tr\u00ean m\u00e1y \u1ea3o / VPS","text":""},{"location":"deployment/vm/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn chi ti\u1ebft deploy LegoCity tr\u00ean VPS \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"deployment/vm/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Setup Ubuntu/Debian server</li> <li>Install Docker v\u00e0 Docker Compose</li> <li>Configure Nginx reverse proxy</li> <li>Setup Let's Encrypt SSL</li> <li>MongoDB installation</li> <li>PM2 process management</li> <li>Monitoring v\u00e0 logging</li> <li>Backup strategies</li> </ul>"},{"location":"dev/blocks/","title":"T\u1ea1o block m\u1edbi trong Payload","text":""},{"location":"dev/blocks/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn t\u1ea1o custom blocks \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"dev/blocks/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Block architecture</li> <li>Create new block component</li> <li>Register block in Payload</li> <li>Styling v\u1edbi Tailwind</li> <li>Props v\u00e0 validation</li> <li>Block examples</li> <li>Testing blocks</li> <li>Best practices</li> </ul>"},{"location":"dev/overview/","title":"Quy \u01b0\u1edbc ph\u00e1t tri\u1ec3n &amp; setup m\u00f4i tr\u01b0\u1eddng","text":""},{"location":"dev/overview/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn setup development environment \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"dev/overview/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Clone repository</li> <li>Install dependencies</li> <li>Development workflow</li> <li>Code style guide</li> <li>Git workflow</li> <li>Testing guidelines</li> <li>Pull request process</li> <li>Documentation standards</li> </ul>"},{"location":"dev/payload-plugins/","title":"Vi\u1ebft plugin PayloadCMS &amp; publish","text":""},{"location":"dev/payload-plugins/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn ph\u00e1t tri\u1ec3n Payload plugins \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"dev/payload-plugins/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Plugin architecture</li> <li>Create plugin structure</li> <li>Plugin hooks v\u00e0 lifecycle</li> <li>Custom endpoints</li> <li>Admin UI extensions</li> <li>Testing plugins</li> <li>Publishing to npm</li> <li>Plugin marketplace</li> </ul>"},{"location":"dev/proxy-security/","title":"B\u1ea3o m\u1eadt proxy &amp; API","text":""},{"location":"dev/proxy-security/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn security best practices \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"dev/proxy-security/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>API key protection</li> <li>Proxy setup</li> <li>Rate limiting</li> <li>CORS configuration</li> <li>Authentication strategies</li> <li>Authorization rules</li> <li>Encryption</li> <li>Security headers</li> <li>Audit logging</li> </ul>"},{"location":"dev/seed-data/","title":"Seed database cho c\u00e1c use case","text":""},{"location":"dev/seed-data/#coming-soon","title":"Coming soon","text":"<p>H\u01b0\u1edbng d\u1eabn t\u1ea1o seed data \u0111ang \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n.</p>"},{"location":"dev/seed-data/#du-kien-noi-dung","title":"D\u1ef1 ki\u1ebfn n\u1ed9i dung","text":"<ul> <li>Seed data structure</li> <li>Traffic use case</li> <li>Environmental monitoring</li> <li>Public services</li> <li>Smart building</li> <li>Custom scenarios</li> <li>Data generation tools</li> <li>Import/export utilities</li> </ul>"},{"location":"usage/","title":"Usage overview","text":"<p>This section explains how to work with the data layer in LegoCity and how it connects to the dashboard.</p> <p>It is intended for people who:</p> <ul> <li>operate or configure context brokers,  </li> <li>build or maintain update servers that push data into the broker,  </li> <li>need to understand how data becomes visible as map layers and blocks in the UI.</li> </ul> <p>The Usage section is organised into the following pages.</p>"},{"location":"usage/#data-brokers","title":"Data &amp; brokers","text":"<p>Describes the overall data flow and the roles of:</p> <ul> <li>the context broker, which stores all NGSI-LD entities, and  </li> <li>update servers, which fetch external data, transform it into entities, and write to the broker.</li> </ul> <p>This page focuses on:</p> <ul> <li>typical broker setups (single vs multiple brokers),  </li> <li>how responsibilities are split between broker and update servers,  </li> <li>why the dashboard reads but does not write to the broker.</li> </ul>"},{"location":"usage/#entities","title":"Entities","text":"<p>Describes how city information is represented as NGSI-LD entities and how Smart Data Models are used.</p> <p>This page covers:</p> <ul> <li>common entity types in a LegoCity deployment,  </li> <li>how Smart Data Models influence attribute naming and structure,  </li> <li>conventions for identifiers, types and geospatial attributes,  </li> <li>guidelines for defining new entity types when requirements change.</li> </ul>"},{"location":"usage/#api-keys-access","title":"API keys &amp; access","text":"<p>Describes how write access to the context broker is controlled.</p> <p>This page explains:</p> <ul> <li>how update servers obtain write access,  </li> <li>patterns for sharing or separating write keys across servers,  </li> <li>where keys and tokens should be stored,  </li> <li>basic expectations for key rotation and incident response.</li> </ul> <p>Read access and the role of read-only proxies are also introduced at a high level.</p>"},{"location":"usage/#sample-update-server","title":"Sample update server","text":"<p>Describes the sample update server included with LegoCity.</p> <p>This page clarifies:</p> <ul> <li>the purpose and scope of the sample,  </li> <li>how it is configured (environment variables, external API, broker access),  </li> <li>the typical workflow to run it end-to-end,  </li> <li>how teams can extend it to build their own update servers.</li> </ul>"},{"location":"usage/#how-to-use-this-section","title":"How to use this section","text":"<p>A typical reading order is:</p> <ol> <li>Data &amp; brokers \u2013 to understand the overall data flow.  </li> <li>Entities \u2013 to learn how city concepts are modeled.  </li> <li>API keys &amp; access \u2013 to see how write access is controlled.  </li> <li>Sample update server \u2013 to run a minimal, practical example.</li> </ol> <p>After working through these pages, you should have a clear picture of how data enters the broker and how it is expected to be structured before it is used by the dashboard.</p>"},{"location":"usage/api-keys/","title":"API keys and access control","text":"<p>This page describes how write access to the context broker is controlled in a LegoCity deployment and how API keys or tokens are shared with update servers and read clients.</p> <p>It is intended for people who:</p> <ul> <li>configure security on the broker and proxy,</li> <li>operate update servers,</li> <li>need to understand how credentials are managed across environments.</li> </ul>"},{"location":"usage/api-keys/#access-patterns","title":"Access patterns","text":"<p>In LegoCity, there are three main classes of access to the broker and related APIs:</p> <ul> <li> <p>Write access to the broker   Granted only to update servers and administrative tools. Used to create and update NGSI-LD entities.</p> </li> <li> <p>Internal read access to the broker   Used by the proxy and internal services to query entities. May have broader permissions but is not exposed to browsers.</p> </li> <li> <p>Public read access via the proxy   Used by the dashboard and any external clients. Constrained to specific endpoints, often with rate limits.</p> </li> </ul> <p>LegoCity recommends:</p> <ul> <li>limiting write access to a small set of controlled services,</li> <li>exposing read access to the UI through a proxy layer, not directly to the broker.</li> </ul>"},{"location":"usage/api-keys/#configuration-variables","title":"Configuration variables","text":"<p>A deployment should standardise how broker endpoints and credentials are passed into services.</p> <p>Typical variables:</p> <ul> <li> <p><code>BROKER_URL</code>   Base URL of the NGSI-LD context broker, for example: <code>https://broker.example.com/ngsi-ld/v1</code></p> </li> <li> <p><code>BROKER_WRITE_KEY</code> or <code>BROKER_WRITE_TOKEN</code>   Credential (token, API key, etc.) for write access.</p> </li> <li> <p><code>BROKER_READ_KEY</code> (optional)   Credential for read access, if the broker enforces read authentication.</p> </li> </ul> <p>These variables are:</p> <ul> <li>defined per environment (development, staging, production),</li> <li>set as environment variables or stored in a secret manager,</li> <li>never committed to the source repository.</li> </ul> <p>Example <code>.env</code> for local development:</p> <pre><code>BROKER_URL=https://dev-broker.example.com/ngsi-ld/v1\nBROKER_WRITE_KEY=dev-broker-write-key\nBROKER_READ_KEY=dev-broker-read-key\n</code></pre> <p><code>.env</code> files should be ignored by version control.</p>"},{"location":"usage/api-keys/#authentication-mechanisms","title":"Authentication mechanisms","text":"<p>The actual authentication mechanism depends on the chosen broker and infrastructure. Common options:</p> <ul> <li> <p>Static API keys or tokens   Keys sent in a header such as <code>Authorization</code> or <code>X-API-Key</code>. Simple to configure.</p> </li> <li> <p>Mutual TLS (mTLS)   Client certificates used to authenticate services. Stronger security, more complex management.</p> </li> <li> <p>OAuth2 / OpenID Connect   Tokens issued by an identity provider. Useful when the broker is part of a larger identity-aware platform.</p> </li> </ul> <p>LegoCity expects that:</p> <ul> <li>update servers use non-interactive methods (no manual logins),</li> <li>credentials are configurable, not hard-coded,</li> <li>the chosen mechanism and required headers are documented for the deployment.</li> </ul>"},{"location":"usage/api-keys/#patterns-for-write-keys","title":"Patterns for write keys","text":"<p>There are multiple ways to assign write keys to update servers. The deployment must choose one and document it.</p>"},{"location":"usage/api-keys/#single-shared-write-key","title":"Single shared write key","text":"<p>All update servers use the same key or token to write to the broker.</p> <p>Characteristics</p> <ul> <li>one write key per broker or per environment.</li> </ul> <p>Advantages</p> <ul> <li>simple to reason about,</li> <li>low administrative overhead.</li> </ul> <p>Drawbacks</p> <ul> <li>if one server is compromised, the same key can be abused from anywhere,</li> <li>revoking the key requires updating all servers at once.</li> </ul> <p>Suitable for small deployments or prototypes.</p>"},{"location":"usage/api-keys/#separate-keys-per-update-server","title":"Separate keys per update server","text":"<p>Each update server has its own write key or token.</p> <p>Characteristics</p> <ul> <li>different credentials for each domain server (<code>env-weather-server</code>, <code>water-flood-server</code>, <code>mobility-parking-server</code>, etc.).</li> </ul> <p>Advantages</p> <ul> <li>compromise of one server does not expose write access from others,</li> <li>access can be revoked for a single server without affecting the rest,</li> <li>possible to assign different scopes per key.</li> </ul> <p>Drawbacks</p> <ul> <li>more credentials to manage,</li> <li>more documentation required to track ownership.</li> </ul> <p>Recommended for serious deployments.</p>"},{"location":"usage/api-keys/#hybrid-patterns","title":"Hybrid patterns","text":"<p>Some deployments may use one key per domain:</p> <ul> <li>one key for environment-related servers,</li> <li>one key for water and flooding,</li> <li>one key for mobility.</li> </ul> <p>The important point is that the pattern is stable, documented, and reflected in monitoring and incident response.</p>"},{"location":"usage/api-keys/#storage-and-distribution","title":"Storage and distribution","text":"<p>Regardless of the pattern, keys must be stored and distributed securely.</p>"},{"location":"usage/api-keys/#acceptable-storage","title":"Acceptable storage","text":"<ul> <li>environment variables injected at deployment time,</li> <li>secret managers provided by cloud platforms,</li> <li>secure configuration stores, separate from the application image.</li> </ul>"},{"location":"usage/api-keys/#unacceptable-storage","title":"Unacceptable storage","text":"<ul> <li>hard-coded keys in source code,</li> <li>keys committed to git repositories,</li> <li>keys shared informally over unencrypted channels.</li> </ul>"},{"location":"usage/api-keys/#example-configuration","title":"Example configuration","text":"<p>For three update servers:</p> <ul> <li><code>env-weather-server</code> </li> <li><code>BROKER_URL</code> </li> <li> <p><code>BROKER_WRITE_KEY_ENV</code></p> </li> <li> <p><code>water-flood-server</code> </p> </li> <li><code>BROKER_URL</code> </li> <li> <p><code>BROKER_WRITE_KEY_WATER</code></p> </li> <li> <p><code>mobility-parking-server</code> </p> </li> <li><code>BROKER_URL</code> </li> <li><code>BROKER_WRITE_KEY_MOBILITY</code></li> </ul> <p>Each service reads its configuration from the environment or a secret manager at startup.</p>"},{"location":"usage/api-keys/#key-rotation","title":"Key rotation","text":"<p>Key rotation replaces existing keys with new ones without long service interruption.</p> <p>A simple rotation process:</p> <ol> <li> <p>Generate new keys    Create new keys or tokens at the broker or gateway. Store them in the secret manager or configuration system.</p> </li> <li> <p>Update services    Update environment variables or config for each update server to use the new key. Restart or reload the servers.</p> </li> <li> <p>Verify operation    Check that update servers continue to write entities successfully. Monitor logs and metrics for write failures.</p> </li> <li> <p>Revoke old keys    Once all services are confirmed to use the new keys, remove or disable the old keys.</p> </li> </ol> <p>The documentation should state:</p> <ul> <li>where keys are defined,</li> <li>who is allowed to rotate them,</li> <li>which monitoring signals indicate a failed rotation.</li> </ul>"},{"location":"usage/api-keys/#read-access-and-the-proxy","title":"Read access and the proxy","text":"<p>Write access and read access must be treated differently.</p>"},{"location":"usage/api-keys/#internal-read-access","title":"Internal read access","text":"<p>Internal services (proxy, analytics) may read directly from the broker. Depending on configuration, read operations may be:</p> <ul> <li>unrestricted inside a trusted network, or</li> <li>protected by a read-only key or token.</li> </ul> <p>If a read-only key is used, it should be:</p> <ul> <li>distinct from write keys,</li> <li>not exposed to browsers.</li> </ul>"},{"location":"usage/api-keys/#public-read-access-via-proxy","title":"Public read access via proxy","text":"<p>The dashboard and public clients should call the proxy, not the broker directly. The proxy:</p> <ul> <li>issues read queries to the broker,</li> <li>transforms responses into simpler structures,</li> <li>enforces caching, rate limits and access control.</li> </ul> <p>Broker credentials (read or write) are never embedded in frontend code. Browsers only see the proxy URL and any proxy-level keys or user authentication mechanisms.</p>"},{"location":"usage/api-keys/#example-scenario","title":"Example scenario","text":"<p>Consider a deployment with:</p> <ul> <li>a broker at <code>https://broker.city.example/ngsi-ld/v1</code>,</li> <li>three update servers: <code>env-weather-server</code>, <code>water-flood-server</code>, <code>mobility-parking-server</code>,</li> <li>one proxy at <code>https://api.city.example</code>.</li> </ul>"},{"location":"usage/api-keys/#broker","title":"Broker","text":"<p>Write tokens configured at the broker or gateway:</p> <ul> <li><code>TOKEN_ENV</code> for environment entities,</li> <li><code>TOKEN_WATER</code> for water and flooding entities,</li> <li><code>TOKEN_MOBILITY</code> for mobility entities.</li> </ul>"},{"location":"usage/api-keys/#update-servers","title":"Update servers","text":"<ul> <li><code>env-weather-server</code> </li> <li><code>BROKER_URL=https://broker.city.example/ngsi-ld/v1</code> </li> <li> <p><code>BROKER_WRITE_TOKEN=TOKEN_ENV</code></p> </li> <li> <p><code>water-flood-server</code> </p> </li> <li><code>BROKER_URL=https://broker.city.example/ngsi-ld/v1</code> </li> <li> <p><code>BROKER_WRITE_TOKEN=TOKEN_WATER</code></p> </li> <li> <p><code>mobility-parking-server</code> </p> </li> <li><code>BROKER_URL=https://broker.city.example/ngsi-ld/v1</code> </li> <li><code>BROKER_WRITE_TOKEN=TOKEN_MOBILITY</code></li> </ul> <p>Each server sends its token in the appropriate header when writing entities.</p>"},{"location":"usage/api-keys/#proxy","title":"Proxy","text":"<ul> <li>runs at <code>https://api.city.example</code>,</li> <li>uses internal credentials or network trust to query the broker,</li> <li>exposes endpoints such as:</li> <li><code>/map/weather</code></li> <li><code>/map/flood-zones</code></li> <li><code>/map/parking-facilities</code></li> </ul> <p>The dashboard calls these endpoints and never sees broker-level tokens.</p>"},{"location":"usage/api-keys/#incident-handling","title":"Incident handling","text":"<p>If a key is exposed or suspected to be compromised:</p> <ul> <li>identify which key was exposed and which services use it,</li> <li>revoke or disable the key at the broker or gateway,</li> <li>generate and distribute a replacement key where necessary,</li> <li>update configuration and restart affected services,</li> <li>review logs for unauthorised write attempts or suspicious patterns.</li> </ul> <p>The documentation should indicate:</p> <ul> <li>where keys can be revoked,</li> <li>which logs or dashboards show broker access,</li> <li>how to verify that entities have not been corrupted.</li> </ul>"},{"location":"usage/api-keys/#summary","title":"Summary","text":"<ul> <li>Update servers are the only components with write access to the broker and use keys or tokens defined via configuration, not in code.</li> <li>A deployment must choose and document a clear pattern for write keys (shared, per-server, or hybrid).</li> <li>Keys must be stored securely, rotated regularly, and revoked immediately if compromised.</li> <li>The dashboard and public clients obtain data through the proxy; broker credentials are never exposed to browsers.</li> <li>Internal read access, external read access, and write access should be configured and monitored separately.</li> </ul>"},{"location":"usage/data-and-brokers/","title":"Data and brokers","text":"<p>This page explains in detail how the data layer of LegoCity is organised around NGSI-LD context brokers and update servers.</p> <p>It focuses on:</p> <ul> <li>what the broker is expected to store and provide,</li> <li>how data is grouped into domains,</li> <li>how update servers are designed and operated,</li> <li>how decisions about history, quality and source-of-truth are made.</li> </ul> <p>It does not cover deployment commands or infrastructure automation; those are documented in the Deployment section.</p>"},{"location":"usage/data-and-brokers/#1-overall-data-flow","title":"1. Overall data flow","text":"<p>The basic data flow in a LegoCity deployment is:</p> <ol> <li>An external system (for example, a weather API, a sensor gateway, a flood model, a transport feed) exposes raw data.</li> <li>An update server for that domain reads the raw data on a schedule.</li> <li>The update server converts the raw data into NGSI-LD entities that follow the agreed models and conventions.</li> <li>The update server writes those entities into a context broker.</li> <li>The dashboard and other application services read entities from the broker (usually via a proxy) and turn them into map layers and UI elements.</li> </ol> <p>The important constraints are:</p> <ul> <li>update servers are the only components that write to the broker in normal operation,</li> <li>the broker is the only source where the dashboard reads city context,</li> <li>if something is not in the broker, it does not exist from LegoCity\u2019s point of view.</li> </ul>"},{"location":"usage/data-and-brokers/#2-context-broker-role","title":"2. Context broker role","text":"<p>The context broker is responsible for:</p> <ul> <li>storing all current state of city entities that LegoCity needs,</li> <li>exposing a standard NGSI-LD API for create, update, query and subscription,</li> <li>providing a consistent, canonical view of \u201cwhat the city looks like right now\u201d.</li> </ul> <p>From LegoCity\u2019s perspective, the broker must:</p> <ul> <li>store entities for all domains in scope (for example, environment, flooding, mobility, public services),</li> <li>support geospatial queries and filtering on attributes that the UI will need,</li> <li>handle the expected volume and update frequency of the entities.</li> </ul> <p>The broker is not expected to:</p> <ul> <li>perform heavy analytics,</li> <li>render maps,</li> <li>be aware of UI concepts like pages, blocks or permissions inside the dashboard.</li> </ul> <p>Those concerns are external to the broker.</p>"},{"location":"usage/data-and-brokers/#21-what-is-stored-in-the-broker","title":"2.1 What is stored in the broker","text":"<p>For each domain, the broker stores:</p> <ul> <li>entity identifiers that represent real-world objects or observations,</li> <li>current values of attributes (status, measurements, capacities, etc.),</li> <li>geospatial attributes (locations, geometries, coverage areas),</li> <li>timestamps that indicate when the information was observed or last updated.</li> </ul> <p>Examples of what is in scope for the broker:</p> <ul> <li>\u201cThere is a flood zone with this polygon and this current risk level.\u201d</li> <li>\u201cThere is a parking facility with this capacity and this current occupancy.\u201d</li> <li>\u201cThere is a weather observation at this location with this temperature and humidity.\u201d</li> </ul> <p>If the dashboard needs to show a value for the user, that value should be present or derivable from entities in the broker.</p>"},{"location":"usage/data-and-brokers/#22-what-is-not-stored-in-the-broker","title":"2.2 What is not stored in the broker","text":"<p>The broker is not required to store:</p> <ul> <li>UI configuration (map styles, layer visibility defaults, panel layouts),</li> <li>user accounts, roles or permissions,</li> <li>documentation or descriptive text that is only relevant for the admin UI.</li> </ul> <p>These items belong to PayloadCMS or other parts of the LegoCity stack.</p>"},{"location":"usage/data-and-brokers/#3-broker-topology","title":"3. Broker topology","text":"<p>A LegoCity deployment must choose how many brokers to run and what each one is responsible for. This is a structural decision that affects every other part of the system.</p>"},{"location":"usage/data-and-brokers/#31-single-broker-deployments","title":"3.1 Single-broker deployments","text":"<p>In a single-broker deployment:</p> <ul> <li>one broker instance stores all entities for the deployment (all domains, all city areas),</li> <li>all update servers write to that broker,</li> <li>all dashboards and application services read from that broker.</li> </ul> <p>This is usually the default for:</p> <ul> <li>proofs of concept,</li> <li>small to medium deployments,</li> <li>a single city or campus.</li> </ul> <p>Advantages:</p> <ul> <li>fewer endpoints to configure,</li> <li>simpler monitoring and logging,</li> <li>easier for new team members to understand.</li> </ul> <p>Risks and constraints:</p> <ul> <li>if the broker is unavailable, all domains are affected,</li> <li>all domains share the same performance and scaling limits,</li> <li>careful naming and scoping is needed to avoid conflicts between domains.</li> </ul> <p>In practice, a single-broker deployment should still separate environments (for example, one broker for development and one for production).</p>"},{"location":"usage/data-and-brokers/#32-multi-broker-deployments","title":"3.2 Multi-broker deployments","text":"<p>In a multi-broker deployment, different brokers are used for different scopes. Common patterns:</p> <ul> <li>one broker per environment (development, staging, production),</li> <li>one broker per city or administrative region,</li> <li>one broker for high-frequency telemetry and another for more static reference data.</li> </ul> <p>Advantages:</p> <ul> <li>clearer separation between environments or cities,</li> <li>different tuning and retention policies per broker,</li> <li>failures in one broker do not immediately affect all domains.</li> </ul> <p>Costs and constraints:</p> <ul> <li>more endpoints and credentials to manage,</li> <li>update servers must know which broker to write to,</li> <li>dashboards and proxies must be configured to query the correct broker for each context.</li> </ul> <p>The documentation of a LegoCity deployment should explicitly list:</p> <ul> <li>each broker instance (name and base URL),</li> <li>which domains and entity types each broker owns,</li> <li>which update servers and applications are allowed to access each broker.</li> </ul>"},{"location":"usage/data-and-brokers/#4-domains-and-ownership","title":"4. Domains and ownership","text":"<p>Without structure, a broker can become a random collection of entities. LegoCity encourages grouping entities into domains and assigning clear responsibility.</p> <p>Typical domains are:</p> <ul> <li>Environment (weather, air quality, noise),</li> <li>Water and flooding,</li> <li>Mobility and transport,</li> <li>Public services (health, education, administration),</li> <li>Infrastructure assets (parking, charging stations, cameras).</li> </ul> <p>For each domain, the documentation should state:</p> <ul> <li>which entity types belong to it (by <code>type</code> name),</li> <li>which update server(s) are responsible for creating and updating those entities,</li> <li>which broker instance stores those entities,</li> <li>which dashboards or map views consume that domain.</li> </ul> <p>This gives a clear answer to questions like:</p> <ul> <li>\u201cIf flood data is wrong, which server should we check?\u201d</li> <li>\u201cWhere does the air quality data come from?\u201d</li> <li>\u201cIf we add a new city, which domains need new brokers or new servers?\u201d</li> </ul> <p>Domains are a documentation and ownership concept; they are not a new technical component.</p>"},{"location":"usage/data-and-brokers/#5-update-servers","title":"5. Update servers","text":"<p>Update servers are integration services. They connect external systems to the context broker and are the only regular writers of entities.</p>"},{"location":"usage/data-and-brokers/#51-responsibilities","title":"5.1 Responsibilities","text":"<p>An update server is responsible for a complete loop:</p> <ol> <li>Configuration    It reads all its configuration from environment variables or configuration files, including:</li> <li>broker URL and credentials,</li> <li>external API endpoints and keys,</li> <li> <p>update frequency and any domain-specific parameters (for example, list of locations to monitor).</p> </li> <li> <p>Data ingestion    It contacts external data sources:</p> </li> <li>fetches raw data,</li> <li>handles paging, rate limits and temporary errors,</li> <li> <p>validates that the received data is structurally sound.</p> </li> <li> <p>Transformation    It converts raw data into the internal entity representation:</p> </li> <li>chooses the entity type,</li> <li>sets identifiers according to the project\u2019s conventions,</li> <li>fills attributes that match the chosen Smart Data Model,</li> <li> <p>sets locations and timestamps.</p> </li> <li> <p>Publishing    It writes entities to the broker:</p> </li> <li>creates entities that do not exist yet,</li> <li>updates attributes for existing entities,</li> <li> <p>handles partial failures and retries where appropriate.</p> </li> <li> <p>Reporting and health    It logs key events:</p> </li> <li>how many entities were created or updated,</li> <li>when the last successful update occurred,</li> <li>whether there were errors and of what kind.</li> </ol> <p>This loop can be implemented as a continuously running service with a timer or as a scheduled job.</p>"},{"location":"usage/data-and-brokers/#52-granularity-and-scope","title":"5.2 Granularity and scope","text":"<p>The recommended approach is to keep update servers narrow in scope:</p> <ul> <li>one server per external data source,</li> <li>or one server per domain when sources are tightly related.</li> </ul> <p>This avoids:</p> <ul> <li>mixing unrelated concerns in a single codebase,</li> <li>making one failure affect many domains,</li> <li>creating hidden couplings that are hard to debug.</li> </ul> <p>Each server should have a clear name and documented scope, for example:</p> <ul> <li><code>env-weather-server</code> \u2013 reads weather API, writes <code>WeatherObserved</code>,</li> <li><code>water-flood-server</code> \u2013 reads flood model outputs, writes <code>FloodZone</code>,</li> <li><code>mobility-parking-server</code> \u2013 reads parking backend, writes <code>ParkingFacility</code> and <code>ParkingSpot</code>.</li> </ul>"},{"location":"usage/data-and-brokers/#53-idempotency-and-conflict-handling","title":"5.3 Idempotency and conflict handling","text":"<p>Update servers should be designed to be idempotent:</p> <ul> <li>running the same update twice in a row should not create duplicate entities,</li> <li>updates should always converge to the correct state.</li> </ul> <p>This has implications for:</p> <ul> <li>how IDs are generated (stable IDs vs new random IDs),</li> <li>how updates are applied (replace vs patch),</li> <li>how deleted or obsolete entities are handled (explicit deletion, or marking as inactive).</li> </ul> <p>The project should define how deletions and deactivations are represented, so the UI can interpret them correctly (for example, whether inactive entities are hidden or styled differently).</p>"},{"location":"usage/data-and-brokers/#6-current-state-and-history","title":"6. Current state and history","text":"<p>NGSI-LD brokers can support both current context and temporal queries, but LegoCity must define how it uses this capability.</p>"},{"location":"usage/data-and-brokers/#61-current-state","title":"6.1 Current state","text":"<p>For many dashboards, only the current state matters. For example:</p> <ul> <li>current water level,</li> <li>current parking occupancy,</li> <li>current flood risk level.</li> </ul> <p>In this mode:</p> <ul> <li>the broker holds one entity per real-world object,</li> <li>each update overwrites relevant attributes,</li> <li>old values are not kept in the broker.</li> </ul> <p>This is simpler to operate and often sufficient for monitoring-style use cases.</p>"},{"location":"usage/data-and-brokers/#62-history-and-trends","title":"6.2 History and trends","text":"<p>For some use cases, LegoCity may need short-term history, for example:</p> <ul> <li>charts of the last 24 hours of weather or air quality,</li> <li>recent evolution of water levels during a flood event.</li> </ul> <p>Two approaches are possible:</p> <ul> <li>use the broker\u2019s temporal features (if available and enabled) to store attribute history,</li> <li>forward data to a specialised time-series database while keeping only the latest values in the broker.</li> </ul> <p>The choice should be documented for each domain:</p> <ul> <li>which domains store only current state,</li> <li>which domains retain a limited history,</li> <li>where long-term analytics data is stored if not in the broker.</li> </ul> <p>The dashboard and proxy must be aligned with this decision so that queries are realistic and efficient.</p>"},{"location":"usage/data-and-brokers/#7-data-contracts-and-conventions","title":"7. Data contracts and conventions","text":"<p>To keep the data layer coherent, LegoCity relies on explicit data contracts between update servers, brokers and the UI.</p> <p>These contracts cover:</p> <ul> <li>which entity types are used,</li> <li>which attributes must be present,</li> <li>which naming conventions are followed.</li> </ul>"},{"location":"usage/data-and-brokers/#71-entity-types-and-models","title":"7.1 Entity types and models","text":"<p>For each entity type used in LegoCity, the documentation should specify:</p> <ul> <li>the name of the entity type (for example, <code>WeatherObserved</code>),</li> <li>whether it follows a FIWARE Smart Data Model directly, an extended version, or a custom schema,</li> <li>which attributes are mandatory (must always be present),</li> <li>which attributes are optional and under which conditions they appear.</li> </ul> <p>Update servers must respect these definitions when creating or updating entities.</p>"},{"location":"usage/data-and-brokers/#72-identifiers","title":"7.2 Identifiers","text":"<p>Identifiers (<code>id</code>) need to be:</p> <ul> <li>stable over time for the same real-world object or location,</li> <li>predictable enough that systems can refer to entities by ID if needed,</li> <li>unique across the broker, or at least across a domain.</li> </ul> <p>The documentation should state:</p> <ul> <li>how IDs are constructed (for example, URN patterns that include domain and location),</li> <li>whether IDs are derived from external identifiers or generated internally,</li> <li>how ID changes are handled if an external system renames something.</li> </ul>"},{"location":"usage/data-and-brokers/#73-geospatial-attributes","title":"7.3 Geospatial attributes","text":"<p>Because LegoCity is map-centric, geospatial attributes must be consistent:</p> <ul> <li>which attribute name is used for location (for example, always <code>location</code>),</li> <li>which types of geometries are expected for each entity type (point, line, polygon),</li> <li>how coordinate reference systems are handled (typically WGS84).</li> </ul> <p>This consistency allows:</p> <ul> <li>generic map layers that can handle many entity types,</li> <li>simple filtering by bounding box or area of interest.</li> </ul>"},{"location":"usage/data-and-brokers/#74-time-attributes","title":"7.4 Time attributes","text":"<p>Time is critical for context:</p> <ul> <li>each observation-type entity should have a clear observation timestamp,</li> <li>entities representing static objects (for example, a public facility) may have creation or last-update timestamps.</li> </ul> <p>The documentation should list:</p> <ul> <li>which attributes carry time information,</li> <li>how they are used in the UI (for example, to mark stale data).</li> </ul>"},{"location":"usage/data-and-brokers/#8-multiple-sources-for-the-same-entity-type","title":"8. Multiple sources for the same entity type","text":"<p>Sometimes more than one external source can provide data for the same conceptual entity type. For example, different agencies might publish partially overlapping flood maps.</p> <p>In such cases, LegoCity needs explicit rules to avoid confusion:</p> <ul> <li>whether one source is considered the authoritative source and others are ignored,</li> <li>whether entities from different sources are kept separate by ID and metadata,</li> <li>whether a dedicated aggregation service combines data from multiple sources into a single set of entities.</li> </ul> <p>If multiple sources are used, the documentation should specify for each entity type:</p> <ul> <li>which sources feed this type,</li> <li>how conflicts are resolved,</li> <li>which attributes indicate the origin or quality of each entity.</li> </ul>"},{"location":"usage/data-and-brokers/#9-subscriptions-and-reactive-flows","title":"9. Subscriptions and reactive flows","text":"<p>NGSI-LD supports subscriptions so that services can be notified when entities change. LegoCity may use subscriptions to drive backend workflows, but not as a primary mechanism for the dashboard.</p> <p>Possible uses include:</p> <ul> <li>a service that updates aggregated indicators when sensor entities change,</li> <li>a monitoring component that alerts when certain thresholds are crossed.</li> </ul> <p>If subscriptions are used:</p> <ul> <li>the components that create and manage subscriptions should be identified,</li> <li>the scopes of subscriptions (which entity types, which conditions) should be documented,</li> <li>error handling and recovery strategies should be defined (what happens when notification delivery fails).</li> </ul> <p>The dashboard is expected to continue using normal queries; any \u201cpush\u201d logic should be mediated by application services.</p>"},{"location":"usage/data-and-brokers/#10-relationship-to-the-dashboard-and-proxy","title":"10. Relationship to the dashboard and proxy","text":"<p>The data layer and the UI layer communicate through a narrow interface.</p> <p>In a typical setup:</p> <ul> <li>the proxy layer exposes a small set of HTTP endpoints tailored to the UI,</li> <li>these endpoints internally query the broker using NGSI-LD and project the results into simpler structures,</li> <li>the dashboard calls these endpoints to obtain the data it needs for map views and blocks.</li> </ul> <p>Consequences:</p> <ul> <li>the broker\u2019s internal details are not exposed directly to browsers or untrusted clients,</li> <li>changes in entity structures can be absorbed by the proxy without immediately breaking the UI,</li> <li>security policies (who can read what) can be implemented in one place.</li> </ul> <p>The design of these proxy endpoints is documented in the Development section; from the data-layer perspective, it is enough to understand that:</p> <ul> <li>read access is centralised,</li> <li>write access remains with update servers,</li> <li>the broker remains the single source of truth.</li> </ul>"},{"location":"usage/data-and-brokers/#11-summary","title":"11. Summary","text":"<ul> <li>The context broker stores the current representation of the city as NGSI-LD entities and is treated as the source of truth.</li> <li>A deployment must choose and document its broker topology (single or multiple brokers) and domain structure.</li> <li>Domains group related entity types and update servers; each domain has clear ownership and responsibilities.</li> <li>Update servers are the only regular writers to the broker and must follow shared data contracts for entity structure, identifiers, geospatial attributes and timestamps.</li> <li>Decisions about history, retention and multiple data sources must be explicit so that the dashboard and analytics behave predictably.</li> <li>The dashboard reads from the broker through a proxy, keeping UI concerns clearly separated from data ingestion and storage.</li> </ul>"},{"location":"usage/entities/","title":"Entities","text":"<p>This page describes how LegoCity represents city information as NGSI-LD entities, how Smart Data Models are used, and what conventions apply to identifiers, attributes and domains.</p> <p>It is intended for people who:</p> <ul> <li>design the data model for a LegoCity deployment,</li> <li>implement update servers that create and update entities,</li> <li>build proxy endpoints or UI layers that query entities.</li> </ul>"},{"location":"usage/entities/#1-role-of-entities-in-legocity","title":"1. Role of entities in LegoCity","text":"<p>In LegoCity, almost everything that appears on the map or in the dashboard is backed by one or more entities.</p> <p>Examples:</p> <ul> <li>a sensor measuring temperature and humidity   \u2192 one <code>WeatherObserved</code> entity per observation point;</li> <li>a flood-prone area   \u2192 one <code>FloodZone</code> entity with a polygon geometry;</li> <li>a public hospital   \u2192 a <code>HealthFacility</code> entity with service attributes and a point location;</li> <li>a parking garage   \u2192 a <code>ParkingFacility</code> entity with capacity, occupancy and status.</li> </ul> <p>The rules are:</p> <ul> <li>if a concept needs to appear in the UI or be queried, it should have a corresponding entity type,</li> <li>update servers create and update entities according to domain-specific logic,</li> <li>the broker stores these entities and provides a consistent view of the city.</li> </ul>"},{"location":"usage/entities/#11-anatomy-of-an-entity-example","title":"1.1 Anatomy of an Entity (Example)","text":"<ul> <li>Before diving into details, here is what a concrete entity looks like in LegoCity (represented in JSON-LD).</li> <li>Notice the <code>type</code>, the <code>id</code>, and how properties are structured with <code>value</code> and <code>unitCode</code>.</li> </ul> <pre><code>{\n  \"id\": \"urn:ngsi-ld:WeatherObserved:ctu:station:STATION_001\",\n  \"type\": \"WeatherObserved\",\n  \"@context\": \"[https://uri.etsi.org/ngsi-ld/v1/ngsi-ld-core-context.jsonld](https://uri.etsi.org/ngsi-ld/v1/ngsi-ld-core-context.jsonld)\",\n  \"temperature\": {\n    \"type\": \"Property\",\n    \"value\": 30.5,\n    \"unitCode\": \"CEL\"\n  },\n  \"location\": {\n    \"type\": \"GeoProperty\",\n    \"value\": {\n      \"type\": \"Point\",\n      \"coordinates\": [105.78, 10.04]\n    }\n  },\n  \"observedAt\": {\n    \"type\": \"Property\",\n    \"value\": \"2023-11-29T10:00:00Z\"\n  }\n}\n## 2. Entity types and domains\n\nA LegoCity deployment should maintain a clear list of **entity types** in use, grouped by **domain**.\n\n### 2.1 Example domain structure\n\nThe exact domains depend on the project, but a typical breakdown is:\n\n- **Environment**\n  - `WeatherObserved` \u2013 point observations of weather at specific locations.\n  - `AirQualityObserved` \u2013 air quality measurements from fixed or mobile sensors.\n\n- **Water and flooding**\n  - `FloodZone` \u2013 polygons representing areas at risk or currently flooded.\n  - `WaterLevel` \u2013 current water levels at specific stations.\n\n- **Mobility and transport**\n  - `ParkingFacility` \u2013 off-street parking structures (garages, lots).\n  - `ParkingSpot` \u2013 individual parking spaces (optional, if needed).\n  - `PublicTransportStop` \u2013 bus or transit stops with location and lines served.\n\n- **Public services**\n  - `HealthFacility` \u2013 hospitals, clinics and related services.\n  - `EducationalFacility` \u2013 schools and universities.\n  - `PublicService` \u2013 administrative or general-purpose public services.\n\n- **Infrastructure and assets**\n  - `ChargingStation` \u2013 EV charging points.\n  - `Camera` \u2013 monitoring cameras.\n\n&gt; Example:\n&gt; A flood dashboard might use `FloodZone` and `WaterLevel` entities, while a mobility dashboard uses `ParkingFacility` and `PublicTransportStop`.\n&gt; Both dashboards read from the same broker but focus on different entity types.\n\n### 2.2 Entity catalogue\n\nFor each entity type in the deployment, the documentation should maintain a catalogue entry.\n\n---\n\n## 3. Smart Data Models\n\nWhere possible, LegoCity should base entity definitions on **FIWARE Smart Data Models**.\n\n### 3.1 Why use Smart Data Models\n\nUsing Smart Data Models provides:\n\n- consistent attribute names across deployments,\n- a clear starting point for new domains,\n- easier reuse of community examples and tools,\n- less ambiguity when multiple teams work on the same domain.\n\n### 3.2 Adoption strategies\n\nFor each entity type, decide one of the following:\n\n- **Direct adoption**\n  Use the Smart Data Model as defined.\n  Example: use `WeatherObserved` exactly as defined in the Smart Data Models documentation.\n\n- **Adoption with extensions**\n  Use the Smart Data Model as a base, but add project-specific attributes.\n  Example:\n  - `WeatherObserved` with an extra attribute `localAlertCode` used only in this city.\n\n- **Custom model**\n  Define a project-specific entity type when no suitable Smart Data Model exists.\n  Example:\n  - `FloodZone` defined around a custom flood risk map that has attributes `riskLevel`, `sourceDataset`, `validUntil`.\n\nFor each type, the entity catalogue should state which strategy was chosen.\n\n### 3.3 The JSON-LD Context (`@context`)\n\nIn NGSI-LD, every entity must include (or link to) a `@context`. This tells the system how to interpret attribute names (e.g., that `temperature` refers to a specific definition in the Smart Data Models dictionary).\n\nIn LegoCity:\n- Update servers must append the correct `@context` URL when sending data.\n- Proxies and dashboards usually work with expanded data or a default context.\n\n---\n\n## 4. Identifiers (`id`)\n\nEntity identifiers must be:\n\n- unique within the broker (or at least within the relevant domain),\n- stable for the lifetime of the entity,\n- predictable enough to support linking between systems.\n\n### 4.1 Identifier patterns\n\nA LegoCity deployment should choose a pattern and document it.\n\nExample patterns:\n\n- For static assets (parking facilities, hospitals):\n  `urn:ngsi-ld:ParkingFacility:ctu:parking:CTU_PARK_A`\n  `urn:ngsi-ld:HealthFacility:ctu:hospital:CTU_HOSP_01`\n\n- For observation entities where one entity represents a **time series at a location**:\n  `urn:ngsi-ld:WeatherObserved:ctu:station:STATION_001`\n  (attributes updated over time, no timestamp in ID)\n\n- For observation entities where each entity represents a **single point in time**:\n  `urn:ngsi-ld:WeatherObserved:ctu:station:STATION_001:2025-11-29T10:00:00Z`\n\nThe choice between the last two patterns affects:\n\n- whether you keep only the latest state in the broker, or\n- whether you want many entities over time for temporal queries.\n\n### 4.2 ID lifecycle\n\nThe docs should clarify for each type:\n\n- whether IDs are permanent (never reused) or can be reassigned,\n- how deletions are handled.\n\nExample:\n\n- `ParkingFacility` entities: IDs are permanent. If a facility closes, a `status` attribute changes to `closed` instead of deleting the entity.\n- `WeatherObserved` (latest-only model): entity persists, attributes are updated; old values are not separately addressed.\n\n---\n\n## 5. Geospatial attributes\n\nBecause LegoCity is map-centric, geospatial attributes must be handled consistently.\n\n### 5.1 Common conventions\n\nA typical convention is:\n\n- use `location` as the main geospatial attribute,\n- represent:\n  - sensors and facilities as **Points**,\n  - zones (flood, administrative) as **Polygons**.\n\nExamples:\n\n- `WeatherObserved.location` \u2192 Point at sensor coordinates.\n- `ParkingFacility.location` \u2192 Point at entrance or centroid.\n- `FloodZone.location` \u2192 Polygon representing the area at risk.\n\nAll coordinates should use the same coordinate reference system, typically WGS84 (`[longitude, latitude]`).\n\n### 5.2 Geospatial expectations per type\n\nFor each entity type, the entity catalogue should specify:\n\n- whether `location` is mandatory,\n- which geometry types are valid.\n\nExample:\n\n- `WeatherObserved` \u2013 `location` required, geometry type: Point.\n- `FloodZone` \u2013 `location` required, geometry type: Polygon.\n- `PublicTransportStop` \u2013 `location` required, geometry type: Point.\n- `PublicService` \u2013 `location` required, geometry type: Point; may also include an address as a separate attribute.\n\n---\n\n## 6. Time attributes\n\nTime attributes indicate when data was observed or last updated.\n\n### 6.1 Observation vs system timestamps\n\nExamples:\n\n- `WeatherObserved`:\n  - `observedAt` \u2013 when the measurement was taken at the station,\n  - `lastUpdate` \u2013 when the update server last wrote this entity (optional).\n\n- `WaterLevel`:\n  - `observedAt` \u2013 time of the water level reading.\n\n- `FloodZone`:\n  - `validFrom` and `validTo` \u2013 interval during which the flood map is valid, or\n  - `lastAssessment` \u2013 when the zone was last assessed.\n\nFor static entities (e.g. `HealthFacility`):\n\n- `createdAt` \u2013 when the entity was created in the system,\n- `modifiedAt` \u2013 when key attributes were last updated.\n\n### 6.2 Usage in LegoCity\n\nThe documentation should specify, per entity type:\n\n- which time attribute the UI uses to decide whether data is \u201cfresh\u201d,\n- whether entries older than a certain threshold should be highlighted or hidden.\n\nExample:\n\n- For `WeatherObserved`, if `observedAt` is older than 3 hours, the UI might:\n  - show a warning icon, or\n  - de-emphasise the marker on the map.\n\n---\n\n## 7. Core attributes and quality\n\nBeyond IDs, location and time, each entity type has domain-specific attributes.\n\n### 7.1 Core attributes\n\nEach entity type should have a small set of **core attributes** that:\n\n- are required for meaningful display,\n- are expected in normal operations,\n- are used for styling and filtering.\n\nExamples:\n\n- `WeatherObserved` (Environment):\n  - `temperature`, `relativeHumidity`, `pressure`, `observedAt`, `location`.\n\n- `FloodZone` (Water &amp; flooding):\n  - `riskLevel` (e.g. low / medium / high),\n  - `status` (e.g. active / inactive),\n  - `location` (Polygon).\n\n- `ParkingFacility` (Mobility):\n  - `totalCapacity`,\n  - `currentOccupancy`,\n  - `status` (open / closed),\n  - `location`.\n\nThe entity catalogue should list these core attributes explicitly.\n\n### 7.2 Data quality and status\n\nSome domains require quality indicators.\n\nExamples:\n\n- `WeatherObserved`:\n  - `qualityIndex` or `validity` flag for sensor readings.\n\n- `AirQualityObserved`:\n  - `aqi` (air quality index),\n  - `source` (provider name),\n  - `confidence` (optional).\n\n- `FloodZone`:\n  - `sourceDataset`,\n  - `confidenceLevel`.\n\nThese attributes can be used to:\n\n- filter out low-quality data in the proxy or UI,\n- display warnings or confidence indicators to users.\n\n---\n\n## 8. Relationships between entities\n\nNGSI-LD relationships explicitly link entities.\n\n### 8.1 Relationship examples\n\nCommon relationship patterns in a smart city context:\n\n- `ParkingSpot` \u2192 `ParkingFacility`\n  Relationship: `belongsToFacility` (spot belongs to facility).\n\n- `PublicService` \u2192 `FloodZone`\n  Relationship: `locatedWithin` (service lies inside a flood zone).\n\n- `WeatherObserved` \u2192 `WeatherStation` (if stations are modelled as separate entities).\n\nThese relationships allow:\n\n- querying all parking spots for a given facility,\n- finding all public services currently within high-risk flood zones,\n- linking observations to their physical stations.\n\n### 8.2 Design guidelines\n\nWhen deciding whether to use a relationship or just duplicate information:\n\n- use relationships when:\n  - multiple entities refer to the same object (e.g. many `ParkingSpot` to one `ParkingFacility`),\n  - you need to keep the central object\u2019s attributes in one place (e.g. facility name, address).\n\n- use duplicated attributes when:\n  - linking is not required,\n  - or when simplicity is more important than normalisation.\n\nFor each relationship used, the docs should specify:\n\n- the source type,\n- the target type,\n- the attribute name for the relationship,\n- cardinality (one-to-one, one-to-many).\n\n### 8.3 Implementation details\n\nTechnically, a relationship in NGSI-LD is different from a regular property. It must uses `\"type\": \"Relationship\"` and stores the target ID in `\"object\"` (not `\"value\"`).\n\nExample of a Parking Spot linked to a Facility:\n\n```json\n\"refParkingFacility\": {\n  \"type\": \"Relationship\",\n  \"object\": \"urn:ngsi-ld:ParkingFacility:ctu:parking:CTU_PARK_A\"\n}\n\n---\n\n## 9. Designing new entity types\n\nWhen new requirements appear, additional entity types may be needed. A consistent process should be followed.\n\n### 9.1 Step-by-step process\n\n1. **Clarify the use case**\n\n   Example:\n   \u201cWe need to show temporary road closures due to construction.\u201d\n\n2. **Check existing models**\n\n   - See if Smart Data Models already have an entity type for this (e.g. road segments, events).\n   - If yes, adapt or extend it.\n\n3. **Define basic properties**\n\n   - Choose a type name, e.g. `RoadClosure`.\n   - Decide if it is static (one entity per road segment) or event-based (one entity per closure event).\n   - Decide which attributes are required:\n     - `location` (line or polygon),\n     - `reason`,\n     - `startTime`, `endTime`,\n     - `affectedTransportModes`.\n\n4. **Choose an ID pattern**\n\n   - Example: `urn:ngsi-ld:RoadClosure:ctu:RC_2025_0001`.\n\n5. **Document the type**\n\n   - Add it to the entity catalogue with domain \u201cMobility\u201d,\n   - Specify which update server will manage it,\n   - Describe attribute semantics briefly.\n\n6. **Implement and test**\n\n   - Update server generates a small number of entities in a test environment,\n   - Dashboard team checks that data appears correctly and the attributes are sufficient.\n\n### 9.2 Example entity definition (summary style)\n\nFor documentation, a concise summary per entity type is often enough:\n\n&gt; **Entity: ParkingFacility**\n&gt; Domain: Mobility\n&gt; Model: FIWARE Smart Data Model (extended with `localCode`)\n&gt; ID pattern: `urn:ngsi-ld:ParkingFacility:&lt;city&gt;:&lt;facilityCode&gt;`\n&gt; Geometry: `location` (Point)\n&gt; Core attributes:\n&gt; - `name`\n&gt; - `totalCapacity`\n&gt; - `currentOccupancy`\n&gt; - `status` (open / closed)\n&gt; - `localCode` (internal identifier)\n\nThis level of detail is usually sufficient for developers and integrators.\n\n---\n\n## 10. Documentation responsibilities\n\nEntity definitions are shared contracts between:\n\n- integration teams (update servers),\n- backend teams (proxy and APIs),\n- frontend teams (dashboard and blocks).\n\nTo avoid divergence:\n\n- keep the entity catalogue under version control alongside the code,\n- treat changes to entity types as changes to a public contract,\n- require that new or modified types are documented before they are used in production data.\n\nEven if a full JSON schema is not maintained, the documentation should always include:\n\n- type name and domain,\n- ID pattern,\n- geospatial and time attributes,\n- core attributes,\n- any important relationships.\n\n---\n\n## 11. Summary\n\n- Entities are the fundamental units of city context in LegoCity; almost everything visible in the UI is backed by entities in the broker.\n- Each deployment should maintain an entity catalogue that lists types, domains, sources, and core attributes, with small concrete examples.\n- Smart Data Models should be used wherever possible; when custom models are needed, they must be described clearly.\n- Identifier patterns, geospatial attributes, time attributes and relationships must follow shared conventions so that queries and visualisations behave predictably.\n- When new entity types are introduced, they should follow a consistent design process, be documented, and be tested end-to-end before adoption.\n</code></pre>"},{"location":"usage/sample-update-server/","title":"Sample update server","text":"<p>This page describes the sample update server that should be included with LegoCity. The sample is a small, self-contained service that shows how to:</p> <ul> <li>read configuration (broker URL, tokens, external API keys),</li> <li>fetch data from an external source,</li> <li>transform it into NGSI-LD entities,</li> <li>write entities to the context broker.</li> </ul> <p>It is intended for:</p> <ul> <li>new users who want to verify their broker and data flow,</li> <li>developers who need a starting point for building real update servers.</li> </ul>"},{"location":"usage/sample-update-server/#purpose-and-scope","title":"Purpose and scope","text":"<p>The sample update server is not a production component. Its goals are:</p> <ul> <li> <p>Demonstration   Show an end-to-end path from an external data source to entities in the broker.</p> </li> <li> <p>Template   Provide a minimal structure that can be copied and extended for real integrations.</p> </li> <li> <p>Verification   Allow operators to quickly confirm that:</p> </li> <li>the broker is reachable,</li> <li>authentication is configured correctly,</li> <li>entities become visible in the dashboard.</li> </ul> <p>The sample server should be:</p> <ul> <li>small enough to read in one sitting,</li> <li>focused on one domain (typically environment),</li> <li>safe to run in a development environment.</li> </ul>"},{"location":"usage/sample-update-server/#example-domain-and-entity-type","title":"Example domain and entity type","text":"<p>To keep the sample concrete, it is recommended to focus on a simple domain such as weather observations.</p> <p>Typical choice:</p> <ul> <li>Domain: Environment  </li> <li>Entity type: <code>WeatherObserved</code> </li> <li>Data source: public weather API or static test data</li> </ul> <p>Expected behaviour:</p> <ul> <li>fetch current weather for one or a few locations,</li> <li>map the response to one or more <code>WeatherObserved</code> entities,</li> <li>write the entities into the broker,</li> <li>optionally repeat this on a timer (e.g. every 5\u201310 minutes).</li> </ul> <p>The entity model should follow the same conventions described in the Entities section:</p> <ul> <li>stable IDs for each location,</li> <li><code>location</code> attribute (Point),</li> <li><code>observedAt</code> timestamp,</li> <li>core attributes such as <code>temperature</code> and <code>relativeHumidity</code>.</li> </ul>"},{"location":"usage/sample-update-server/#repository-location","title":"Repository location","text":"<p>The LegoCity repository should contain the sample update server in a clearly named directory, for example:</p> <ul> <li><code>services/sample-update-server/</code></li> <li>or <code>examples/update-server-weather/</code></li> </ul> <p>The directory should include:</p> <ul> <li>the application code,</li> <li>a minimal README specific to the server,</li> <li>configuration examples (e.g. <code>.env.example</code>),</li> <li>any scripts or Dockerfiles used to run it.</li> </ul> <p>This documentation page describes the intended behaviour; the repository holds the actual implementation details.</p>"},{"location":"usage/sample-update-server/#configuration","title":"Configuration","text":"<p>The sample update server must be configurable only through environment variables or configuration files, not by editing source code.</p> <p>Typical configuration variables:</p> <ul> <li>broker connection:</li> <li> <p><code>BROKER_URL</code>     Base URL of the NGSI-LD context broker.</p> </li> <li> <p><code>BROKER_WRITE_KEY</code> or <code>BROKER_WRITE_TOKEN</code>     Credential used to authenticate write operations.</p> </li> <li> <p>external data source:</p> </li> <li> <p><code>WEATHER_API_URL</code>     Base URL of the weather data API (or endpoint).</p> </li> <li> <p><code>WEATHER_API_KEY</code> (optional)     API key or token, if required by the external service.</p> </li> <li> <p>application behaviour:</p> </li> <li><code>UPDATE_INTERVAL_SECONDS</code>     How often the server fetches data and updates entities.</li> <li><code>LOCATIONS</code>     List of locations or station identifiers to be monitored (format decided by the implementation).</li> </ul> <p>Example <code>.env</code> for development:</p> <pre><code>BROKER_URL=https://dev-broker.example.com/ngsi-ld/v1\nBROKER_WRITE_KEY=dev-broker-write-key\nWEATHER_API_URL=https://api.example.com/weather\nWEATHER_API_KEY=dev-weather-api-key\nUPDATE_INTERVAL_SECONDS=300\nLOCATIONS=CTU_CAMPUS,CTU_CITY_CENTER\n</code></pre> <p>The actual names and formats may differ, but they must be documented clearly in the sample server README.</p>"},{"location":"usage/sample-update-server/#high-level-workflow","title":"High-level workflow","text":"<p>The sample update server follows a simple loop:</p> <ol> <li>Load configuration </li> <li>read broker settings,</li> <li>read external API settings,</li> <li>read list of locations or stations,</li> <li> <p>read update interval.</p> </li> <li> <p>Fetch external data </p> </li> <li>for each location in <code>LOCATIONS</code>, call the weather API,</li> <li>handle basic errors (network issues, invalid response),</li> <li> <p>log failures without crashing immediately.</p> </li> <li> <p>Transform to entities </p> </li> <li> <p>for each location and corresponding response:</p> <ul> <li>choose an entity ID (e.g. <code>urn:ngsi-ld:WeatherObserved:ctu:station:CTU_CAMPUS</code>),</li> <li>build an entity with:</li> <li><code>type = \"WeatherObserved\"</code>,</li> <li><code>location</code> as a geospatial attribute (Point),</li> <li><code>observedAt</code> time,</li> <li>core attributes (e.g. <code>temperature</code>, <code>relativeHumidity</code>, <code>pressure</code>),</li> <li>follow the project\u2019s entity conventions.</li> </ul> </li> <li> <p>Write entities to the broker </p> </li> <li>send create or update requests to the broker\u2019s entities endpoint,</li> <li>handle HTTP errors and log them,</li> <li> <p>confirm success with basic logging (e.g. \u201cupdated 2 entities\u201d).</p> </li> <li> <p>Wait and repeat </p> </li> <li>sleep for <code>UPDATE_INTERVAL_SECONDS</code>,</li> <li>repeat the loop while the process is running.</li> </ol> <p>In a development environment, a single iteration (no loop) may be sufficient to confirm configuration.</p>"},{"location":"usage/sample-update-server/#running-the-sample-server","title":"Running the sample server","text":"<p>The exact commands depend on the stack used (for example Go, Node.js, or another language), but the general process is:</p> <ol> <li> <p>Prepare the environment</p> </li> <li> <p>ensure that a context broker is running and reachable at the URL you plan to use,</p> </li> <li> <p>ensure that a write key or token is configured and valid.</p> </li> <li> <p>Clone the repository</p> </li> <li> <p>clone the LegoCity repository,</p> </li> <li> <p>change into the sample server directory:</p> <ul> <li>e.g. <code>cd services/sample-update-server</code>    or <code>cd examples/update-server-weather</code>.</li> </ul> </li> <li> <p>Create configuration</p> </li> <li> <p>copy the example configuration file, for example:</p> <ul> <li>copy <code>.env.example</code> to <code>.env</code>,</li> <li>fill in:</li> <li><code>BROKER_URL</code>,</li> <li><code>BROKER_WRITE_KEY</code> or token,</li> <li><code>WEATHER_API_URL</code>,</li> <li><code>WEATHER_API_KEY</code> if needed,</li> <li><code>LOCATIONS</code> and <code>UPDATE_INTERVAL_SECONDS</code>.</li> </ul> </li> <li> <p>Install dependencies</p> </li> <li> <p>install dependencies according to the implementation (for example, <code>npm install</code>, or build a Go binary).</p> </li> <li> <p>Run the server</p> </li> <li> <p>start the application (for example, <code>npm run start</code> or <code>./sample-update-server</code>),</p> </li> <li> <p>check logs to ensure that:</p> <ul> <li>configuration was loaded,</li> <li>requests to the external API succeeded,</li> <li>entities were written to the broker.</li> </ul> </li> <li> <p>Verify in the broker and dashboard</p> </li> <li> <p>query the broker or use its management UI to confirm that:</p> <ul> <li><code>WeatherObserved</code> entities exist,</li> <li>attributes and locations have reasonable values.</li> </ul> </li> <li>if the LegoCity dashboard is running:<ul> <li>open the corresponding map view,</li> <li>confirm that weather markers appear in the expected locations.</li> </ul> </li> </ol>"},{"location":"usage/sample-update-server/#expected-behaviour-and-logs","title":"Expected behaviour and logs","text":"<p>The sample server should produce clear, minimal logs. Examples of log messages (conceptually):</p> <ul> <li>on startup:</li> <li> <p>\u201cLoaded configuration: 2 locations, update interval 300 seconds.\u201d</p> </li> <li> <p>on successful update:</p> </li> <li>\u201cFetched weather data for CTU_CAMPUS (temperature 30.1 \u00b0C).\u201d</li> <li>\u201cUpdated entity urn:ngsi-ld:WeatherObserved:ctu:station:CTU_CAMPUS.\u201d</li> <li> <p>\u201cUpdate cycle completed: 2 entities updated.\u201d</p> </li> <li> <p>on error:</p> </li> <li>\u201cFailed to fetch weather data for CTU_CITY_CENTER: HTTP 500 from API.\u201d</li> <li>\u201cFailed to write entity urn:... to broker: HTTP 401 (unauthorized).\u201d</li> </ul> <p>The aim is to make it easy for operators to see:</p> <ul> <li>whether external data is available,</li> <li>whether authentication with the broker works,</li> <li>whether the data contract (entity structure) is being respected.</li> </ul>"},{"location":"usage/sample-update-server/#extending-the-sample-server","title":"Extending the sample server","text":"<p>Once the sample server works in development, teams can:</p> <ul> <li>duplicate the project and adapt it for other domains (e.g. flood or parking),</li> <li>or extend the same server to handle additional entity types.</li> </ul> <p>Recommended practices when extending:</p> <ul> <li>keep configuration domain-specific:</li> <li>new environment variables for new sources,</li> <li> <p>structured configuration for multiple domains if using a single process.</p> </li> <li> <p>keep transformation logic separate per entity type:</p> </li> <li>one function or module per type (<code>WeatherObserved</code>, <code>FloodZone</code>, etc.),</li> <li> <p>avoid mixing unrelated transformations into one large block.</p> </li> <li> <p>keep logging and error handling consistent:</p> </li> <li>similar log messages across servers,</li> <li>clear error codes and descriptions.</li> </ul>"},{"location":"usage/sample-update-server/#relationship-to-other-documentation","title":"Relationship to other documentation","text":"<p>This page focuses on the conceptual behaviour and configuration of the sample update server.</p> <p>Related documents:</p> <ul> <li> <p>Data and brokers   Explains the overall data flow and the roles of brokers and update servers.</p> </li> <li> <p>Entities   Describes entity types, domains, and data contracts that the sample must follow.</p> </li> <li> <p>API keys and access control   Explains how write tokens and broker URLs are configured and managed.</p> </li> </ul> <p>The sample update server should implement the patterns described in these documents, so that it serves as a realistic example for future integrations.</p>"},{"location":"usage/sample-update-server/#summary","title":"Summary","text":"<ul> <li>The sample update server is a small, self-contained service that demonstrates how to fetch external data, transform it into NGSI-LD entities, and write those entities to the broker.</li> <li>It is designed to be easy to run in development to verify configuration and data flow.</li> <li>Configuration is handled through environment variables, including broker connection details, external API settings, locations, and update intervals.</li> <li>The sample focuses on one entity type (typically <code>WeatherObserved</code> in the Environment domain) but can be extended or duplicated for other domains.</li> <li>Logs should make it clear whether external data, broker access, and entity creation are working as expected.</li> <li>The implementation must align with the data contracts and security patterns defined in the rest of the LegoCity documentation.</li> </ul>"}]}